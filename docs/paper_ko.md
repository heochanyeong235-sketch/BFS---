# 루빅스 큐브 크로스(Cross) 최단해 탐색기 개발: 스티커 기반 모델링, 큐비 모델 변환, 축소 상태공간 BFS, 그리고 시각화 도구

## 초록 (Abstract)
본 프로젝트는 3×3×3 루빅스 큐브에서 **크로스(Cross)** 단계(특정 면의 엣지 4개를 올바른 위치·방향으로 맞추는 문제)에 대해, 입력 상태(스크램블)로부터 **짧은(최단) 해법**을 계산하고 이를 사용자가 직접 검증할 수 있도록 돕는 도구를 구현한다. 구현은 (1) 큐브를 6×3×3 스티커 배열로 표현하는 코어 모델, (2) 스티커 상태를 큐비(permutation/orientation) 표현으로 변환하는 변환 계층, (3) 크로스에만 집중한 축소 상태공간에서의 BFS 거리 테이블 기반 솔버, (4) 무브 적용을 즉시 확인하고 스크램블 입력 및 해법을 표시할 수 있는 Tkinter 시각화 GUI로 구성된다.

## 1. 서론 (Introduction)
### 1.1 배경
루빅스 큐브 해법은 일반적으로 여러 단계로 구성되며, 그 중 크로스는 이후 단계의 효율과 전체 해법 품질에 영향을 준다. 본 프로젝트는 "전체 큐브 완성"이 아니라 **크로스만을 빠르게 최단으로** 푸는 것에 초점을 맞춘다.

### 1.2 목표
- 3×3×3 큐브 상태를 명확한 자료구조로 표현하고, 무브를 정확히 적용할 수 있게 한다.
- 스티커 표현을 큐비(permutation/orientation) 표현으로 변환해 AI/탐색에 유리한 상태를 얻는다.
- 크로스 문제에 대해서는 축소된 상태공간에서 BFS 기반으로 최단해를 빠르게 산출한다.
- 사용자가 모든 무브를 클릭으로 적용하고, 스크램블을 직접 입력하고, 계산된 크로스 해법을 즉시 확인할 수 있도록 시각화 도구를 제공한다.

### 1.3 범위(Non-goals)
- 본 프로젝트의 핵심은 크로스 단계이며, F2L/OLL/PLL 등 전체 해법 생성은 범위에서 제외한다.

## 2. 시스템 개요 (System Overview)
프로젝트는 다음 모듈로 구성된다.
- core: 큐브 스티커 상태 및 무브 엔진
- conversion: 스티커 → 큐비 상태 변환
- ai: 큐비 상태 컨테이너 및 크로스 솔버(BFS 거리 테이블)
- visualization: 전개도 기반 렌더 및 GUI
- utils: 스크램블 생성
- examples/tests: 실행 예시와 검증

## 3. 큐브 상태 표현 및 무브 엔진 (Modeling & Move Engine)
### 3.1 스티커 기반 표현
큐브는 6×3×3 정수 배열로 표현된다. 각 원소는 색상 코드를 의미하며, 솔브 상태는 면별 단색으로 초기화된다.

### 3.2 무브 적용
무브 엔진은 R/L/U/D/F/B(및 프라임/2회전)를 포함하여, 회전/슬라이스/와이드 무브까지 토큰 단위로 적용한다. 이 계층의 목표는 **정확성**이며, 이후 변환 및 탐색 단계는 이 결과를 신뢰한다.

## 4. 스티커→큐비 변환 (Sticker-to-Cubie Conversion)
스티커 배열로부터 코너/엣지 조각의 (1) 퍼뮤테이션(permutation)과 (2) 오리엔테이션(orientation)을 산출한다.
- 코너: 조각 ID 및 U/D 색상의 위치를 기반으로 orientation을 판별
- 엣지: 솔브 상태에서의 기대 색상 순서를 기준으로 orientation을 판별

이 변환은 탐색/검증 로직에서 “스티커 배열 전체”를 직접 다루는 비용을 줄이고, 퍼뮤테이션 기반의 빠른 상태 판정을 가능하게 한다.

## 5. 크로스 솔버 설계 (Cross Solver)
### 5.1 문제 축소
전체 큐브 상태공간은 매우 크다. 크로스만을 목표로 할 경우, 관심 대상은 특정 면의 **엣지 4개**이며, 다른 조각의 상태는 무시할 수 있다. 본 프로젝트는 이 관찰을 활용해 상태를 다음으로 축소한다.
- 목표 엣지 4개의 현재 위치(12개 중 4개 위치)
- 목표 엣지 4개의 방향(각각 0/1)

### 5.2 거리 테이블 기반 BFS
축소 상태공간의 모든 상태에 대해, 목표 상태(크로스 완성)까지의 최단 거리를 BFS로 계산한 뒤 배열로 저장한다. 이후 실제 풀이에서는 시작 상태에서 거리 값을 따라 내려가며 해법을 복원한다.

### 5.3 캐싱
거리 테이블 계산은 최초 1회 비용이 크므로, 테이블을 파일로 저장해 재실행 시 로딩하여 속도를 개선한다(버전/무브 토큰/상태 수가 일치할 때만 유효).

### 5.4 다면 크로스 비교
한 가지 면만이 아니라 U/D/F/B/L/R 6개 면의 크로스를 모두 시도하고, 가장 짧은 해법(동률이면 모두)을 반환하는 인터페이스를 제공한다.

## 6. 시각화 및 사용자 검증 도구 (Visualization & Verification)
Tkinter 기반 GUI는 다음을 제공한다.
- 전개도(2D net) 형태로 현재 큐브 상태 표시
- 모든 지원 무브를 버튼으로 제공하여 즉시 상태 변화 확인
- 스크램블 문자열 직접 입력 및 적용
- 랜덤 20수 스크램블 생성
- 현재 상태에 대한 크로스 최단 해법 계산 및 표시

이는 알고리즘의 결과를 사용자 눈으로 즉시 확인할 수 있도록 하여, 디버깅과 신뢰성 확보에 기여한다.

## 7. 실험 및 검증 (Evaluation)
### 7.1 단위 테스트
코어 무브/변환/솔버 관련 기본 검증을 단위 테스트로 수행한다.

### 7.2 기능 시나리오 테스트
- 임의 스크램블 적용 후 크로스 솔루션 계산
- 솔루션을 적용했을 때 해당 면 크로스가 완료되었는지 확인
- GUI에서 무브 버튼/스크램블 입력/랜덤 스크램블/리셋의 상태 일관성 확인

## 8. 한계 및 향후 과제 (Limitations & Future Work)
- 크로스만 다루므로 전체 해법으로 확장하려면 F2L/OLL/PLL 단계에 대한 상태 축소·휴리스틱·탐색 전략이 추가로 필요하다.
- GUI는 검증 목적의 2D 전개도이며, 3D 렌더링이나 애니메이션은 범위 밖이다.
- 성능/최단성은 크로스 축소 상태공간에 대해 보장되며, 전체 큐브 문제에 대한 보장은 아니다.

## 9. 결론 (Conclusion)
본 프로젝트는 큐브를 명확히 모델링하고, 스티커 표현을 큐비 상태로 변환해, 크로스 문제를 축소 상태공간으로 정의한 뒤 BFS 거리 테이블을 통해 빠르게 최단해를 구하는 구현을 완성했다. 또한 GUI 기반 검증 도구를 제공하여 개발·검증·학습의 선순환을 가능하게 했다.

---

## 부록 A. 재현 방법 (Reproducibility)
- GUI 실행: `./.venv/Scripts/python.exe examples/run_visualizer.py`
- 테스트 실행: `./.venv/Scripts/python.exe -m unittest -q`
